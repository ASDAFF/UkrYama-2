
<?php 

$baseUrl = Yii::app()->baseUrl; 
$cs = Yii::app()->getClientScript();
$cs->registerCssFile($baseUrl.'/css/apipage.css');
$cs->registerCssFile($baseUrl.'/css/bootstrap.min.css');
$cs->registerCssFile($baseUrl.'/css/bootstrap-responsive.min.css');
?>



  <div class="container">

      <div class="span9">


        <!-- Overview
        ================================================== -->
        <section id="overview">
          <div class="page-header">
            <h1>API УкрЯмы</h1>
          </div>

          <p>Соответствует текущей версии <code><?php echo Yii::app()->params['version'];?></code> УкрЯмы.</p>

          <p>Общение с сервером УкрЯмы любое внешнее приложение осуществляет посредством запроса к серверу по протоколу <code>http</code>, а лучше — <code>https</code> на определённый адрес. Сервер в ответ присылает <code>XML</code>.</p>

          <p>Запросы могут быть посланы как методом <code>GET</code>, так и методом <code>POST</code>, в зависимости от запроса. В случае, если приложение отправляет запрос методом <code>GET</code>, то может передать какие-нибудь данные в строке <code>URL</code>, а также в строке <code>URL</code> содержится тип запроса. Проще говоря, в зависимости от того, что приложение хочет получить и сообщить, оно формирует запрос на определённый <code>URL</code>. Запросы методом <code>POST</code> используются для отправки на сервер больших объёмов информации (загрузка картинок и так далее), а также могут быть использованы для выполнения запросов, которые требуют авторизации. Все запросы, для которых авторизация не требуется, отправляются на сервер методом <code>GET</code>.</p>

	  <p>Промышленный сервер, который принимает запросы: <a href="http://ukryama.com/xml/">ukryama.com/xml/</a>.</p>

	  <p>Тестовый сервер, на котором можно отлаживать приложения: <a href="http://test.ukryama.com/xml/">test.ukryama.com/xml/</a>.</p>


	<div class="alert alert-info">
            <strong>Следует помнить,</strong>
            что тестовый сервер обычно имеет более свежую версию исходного кода и может работать (что обычно и происходит) менее стабильно, чем промышленный, так как изменения происходят там в непрерывном режиме, а на промышленный сервер переносятся пачками время от времени.
          </div>

	  <p>Текущая версия <code>API</code> на промышленном сервере описана по адресу <a href="http://ukryama.dev/page/api/">http://ukryama.dev/page/api/</a>.</p>

          <p>Начиная работу имейте ввиду, что любые манипуляции с данными кроме открытой информации происходит после авторизации и возвращении passwordhash, который Вы будете использовать для дальнешей работы с сервером.</td>
			
        </section>


        <!-- XML Response
        ================================================== -->
        <section id="xml-response">
          <div class="page-header">
            <h1>Формат XML ответа сервера</h1>
          </div>

	<p>Валидный ответ сервера выглядит следующим образом:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt; тут время запроса (таймстамп) &lt;/requesttime&gt;
	&lt;requestmethod&gt; тут метод запроса (обычно GET или POST) &lt;/requestmethod&gt;
	&lt;replytime&gt; тут время ответа сервера (таймстамп) &lt;/replytime&gt;
	
	Тело ответа.
	
&lt;/st1234reply&gt;</pre>

	<p>Сервер принимает запросы и выдаёт ответы в кодировке <code>UTF-8</code>. Использование иной кодировки в запросе не запрещается, но и не гарантирует адекватные ответы.</p>

        </section>

        <!-- XML Errors
        ================================================== -->
        <section id="xml-errors">
          <div class="page-header">
            <h1>Формат XML ошибок</h1>
          </div>

	<p>В случае каких-либо проблем или ошибок, которые сервер может обработать, он отвечает <code>XML</code> с описанием ошибки. <code>XML</code> ошибки содержит внутри ответа элемент <code>&lt;error/&gt;</code>, у которого есть свойство code, а в себе он содержит текст ошибки. Например:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1307535706&lt;/requesttime&gt;
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt;
	&lt;replytime&gt;1307535707&lt;/replytime&gt;
	&lt;error code="NOT_IMPLEMENTED"&gt;Метод не реализован&lt;/error&gt;
&lt;/st1234reply&gt;</pre>
	<p>Ниже представлен перечень кодов ошибок, которые сервер может возвращать:</p>
	<table class="table table-bordered table-striped">
		<tr>
			<td>NOT_IMPLEMENTED</td>
			<td>Метод не реализован</td>
		</tr>
		<tr>
			<td>NOT_FOUND</td>
			<td>Запрашиваемый ресурс не найден</td>
		</tr>
		<tr>
			<td>NO_FILES</td>
			<td>Не загружено ни одного файла</td>
		</tr>
		<tr>
			<td>TOO_BIG_FILE</td>
			<td>Слишком большой файл</td>
		</tr>
		<tr>
			<td>TOO_MANY_FILES</td>
			<td>Слишком много файлов</td>
		</tr>
		<tr>
			<td>PARTIALLY_UPLOADED_FILE</td>
			<td>Файл загружен только частично</td>
		</tr>
		<tr>
			<td>CANNOT_UPLOAD_FILE</td>
			<td>Невозможно загрузить файл</td>
		</tr>
		<tr>
			<td>UNKNOWN_MIME_TYPE</td>
			<td>Неподдерживаемый тип файла</td>
		</tr>
		<tr>
			<td>UNKNOWN_IMAGE_FORMAT</td>
			<td>Неподдерживаемый формат изображения</td>
		</tr>
		<tr>
			<td>INCORRECT_TYPE</td>
			<td>Неправильный тип дефекта</td>
		</tr>
		<tr>
			<td>DEPRECATED_TYPE</td>
			<td>Неиспользуемый в данный момент тип дефекта</td>
		</tr>
		<tr>
			<td>CANNOT_ADD_DEFECT</td>
			<td>Невозможно добавить дефект</td>
		</tr>
		<tr>
			<td>AUTHORIZATION_REQUIRED</td>
			<td>Требуется авторизация</td>
		</tr>
		<tr>
			<td>LATITUDE_NOT_SET</td>
			<td>Не указана широта дефекта</td>
		</tr>
		<tr>
			<td>LONGITUDE_NOT_SET</td>
			<td>Не указана долгота дефекта</td>
		</tr>
		<tr>
			<td>NO_ADDRESS</td>
			<td>Не указан адрес</td>
		</tr>
		<tr>
			<td>WRONG_CREDENTIALS</td>
			<td>Неправильный логин и/или пароль</td>
		</tr>
		<tr>
			<td>UNAPPROPRIATE_METHOD</td>
			<td>Неподходящий метод</td>
		</tr>
		<tr>
			<td>CANNOT_UPDATE_DEFECT</td>
			<td>Не удалось обновить дефект</td>
		</tr>
		<tr>
			<td>CANNOT_DELETE_DEFECT</td>
			<td>Не удалось удалить дефект</td>
		</tr>
		<tr>
			<td>GEOCODE_ERROR</td>
			<td>Не удалось произвести геокодирование</td>
		</tr>
		<tr>
			<td>GEOCODE_EMPTY_REQUEST</td>
			<td>Пустой запрос к геокодеру</td>
		</tr>
		<tr>
			<td>INTERNAL</td>
			<td>Иная внутренняя ошибка</td>
		</tr>
	</table>

        </section>



        <!-- Warnings
        ================================================== -->
        <section id="warnings">
          <div class="page-header">
            <h1>Формат предупреждений</h1>
          </div>

	<p>Помимо ошибок, сервер может возвращать предупреждения. Тэг предупреждения имеет следующий формат:</p>
	<pre>&lt;warning code="WARNING"&gt;Это предупреждение&lt;/warning&gt;</pre>
	<p>Предупреждений может быть несколько, и они могут соседствовать с прочими элементами в ответе сервера. Предупреждения могут быть возвращены в ответах не на все запросы, а только на некоторые, и все возможные случаи описаны отдельно. Обрабатывать предупреждения или нет — дело разработчика приложения.</p>
	<p>Возможные предупреждения, который может возвращать сервер:</p>
	<table class="table table-bordered table-striped">
		<tr>
			<td>FILES_DROPPED</td>
			<td>Несколько файлов не загружено на сервер</td>

		<tr>
			<td>CANNOT_REALISE_CITY</td>
			<td>Не удалось распознать город</td>
		</tr>
		<tr>
			<td>FILES_LIMIT_REACHED</td>
			<td>Достигнуто максимальное количество файлов для одного дефекта</td>
		</tr>

	</table>

        </section>



        <!-- xml-description
        ================================================== -->
        <section id="xml-description">
          <div class="page-header">
            <h1>Формат XML описания дефекта</h1>
          </div>

	<p>В разных запросах могут приходить описания разных дефектов. В списке дефектов их несколько, в карточке дефекта — он, соответственно, один. Во всех случаях <code>XML</code> с описанием дефекта выглядит одинаково.</p>
	<pre>&lt;hole id="номер дефекта"&gt;
	&lt;id&gt; номер дефекта &lt;/id&gt;
	&lt;archive&gt; находится ли яма в архиве (boolean) &lt;/archive&gt;
	&lt;username full="полоное имя пользователя" user_id="ID пользователя"&gt;
		&lt;name&gt;имя&lt;/name&gt;
		&lt;secondname&gt;отчество&lt;/secondname&gt;
		&lt;lastname&gt;фамилия&lt;/lastname&gt;
	&lt;/username&gt;
	&lt;latitude&gt; широта &lt;/latitude&gt;
	&lt;longitude&gt; долгота &lt;/longitude&gt;
	&lt;address city="название города" gt;полный адрес дефекта&lt;/address&gt;
	&lt;state code="код статуса дефекта"&gt; название статуса&lt;/state&gt;
	&lt;type code="код типа дефекта"&gt; название типа&lt;/type&gt;
	&lt;datecreated readable="02.06.2011"&gt;1307003591&lt;/datecreated&gt; - дата создания дефекта
	&lt;datesent readable="02.06.2011"&gt;1307003789&lt;/datesent&gt; - дата отправки заявления в ГАИ
	&lt;datestatus readable="02.06.2011"&gt;1307003797&lt;/datestatus&gt; - дата простановки текущего статуса
	&lt;commentfresh&gt;комментарий пользователя к дефекту&lt;/commentfresh&gt;
	&lt;commentfixed&gt;комментарий, который пользователь оставляет при отметке дефекта, как починенного&lt;/commentfixed&gt;
	&lt;commentgibddre&gt;комментарий, который пользователь оставляет при простановке статуса «пришёл ответ из ГАИ»&lt;/commentgibddre&gt;
	&lt;pictures&gt;
		&lt;original&gt; - картинки оригинального размера (ну на самом деле не оригинального, я ужатого до 1024 пикселей по ширине для экономии места на сервере)
			&lt;fresh&gt; - картинки к «свежему» дефекту, загружаемые на сайт при добавлении дефекта. Этот элемент (равно как и соседние с ним &lt;gibddreply&gt; и &lt;fixed&gt;) может иметь внутри любое (в том числе и нулевое) количество элементов &lt;src&gt;, в которых содержатся пути к картинкам дефектов относительно корня http-сервера (обычного, где крутится сайт)
				&lt;src id=&quot;123&quot;&gt;src&lt;/src&gt; - путь к каринке и ее ID
				&lt;src id=&quot;124&quot;&gt;src&lt;/src&gt;
				...
			&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/original&gt;
		&lt;medium&gt; - картинки среднего размера, которые показываются на сайте внутри карточки дефекта
			&lt;fresh&gt;...&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/medium&gt;
		&lt;small&gt; - картинки маленького размера
			&lt;fresh&gt;...&lt;/fresh&gt;
			&lt;gibddreply&gt;...&lt;/gibddreply&gt;
			&lt;fixed&gt;...&lt;/fixed&gt;
		&lt;/small&gt;
	&lt;/pictures&gt;
	&lt;gibddrequests&gt; - запросы в ГАИ<br>		&lt;request id=&quot;6&quot; gibdd_id=&quot;75&quot; date=&quot;1326669064&quot; user_id=&quot;2&quot; user_name=&quot;Иванов Иван&quot;&gt; - ID запроса, ID ГАИ, время отправки и имя пользователя<br>			&lt;answer id=&quot;2&quot; date=&quot;1326729513&quot;&gt; - Ответ из ГАИ и его время<br>				&lt;files&gt;<br>					&lt;file id=&quot;7&quot; type=&quot;image&quot;&gt;src&lt;/file&gt; - Один из загруженых файлов, допустимые типы &quot;image&quot;, &quot;application/pdf&quot; и &quot;text/plain&quot;<br>						...<br>				&lt;/files&gt;<br>			&lt;/answer&gt;<br>		&lt;/request&gt;<br>	&lt;/gibddrequests&gt;
&lt;/hole&gt;</pre>

        </section>



        <!-- defects-list
        ================================================== -->
        <section id="defects-list">
          <div class="page-header">
            <h1>Список дефектов</h1>
          </div>

	<p>Список дефектов получается простым запросом к корню http-сервера методом <code>GET</code>. Могут быть переданы параметры, влияющие на фильтрацию, возможно, упорядочивание и отображение списка дефектов. Например:</p>
	<pre>GET /?filter_type=holeonroad&filter_status=fixed</pre>
	<p>Приведённый запрос отфильтрует выведет дефекты, типа «яма на дороге» и в статусе «починенные». Просто запрос <code>GET /</code> выведет все ямы. Список дефектов можно получать без авторизации.</p>
	<p>Возможные параметры, которые могут быть переданы в запросе:</p>
	<table class="table table-bordered table-striped">
		
		<tr>
			<td>filter_city</td>
			<td>
				Фильтр по названию города (или по его началу). Если указать, например, «Волг», то будут выбраны ямы, расположенные в Волгограде, Волгодонске и во прочих всех городах, название которых начинается на «Волг».<br/>
				Соответствует имени поля <code>ADR_CITY</code>.<br/>
				Если соответствующий фильтр задан, но равен пустой строке, то будут выбраны дефекты, не привязанные к городам (неправильный формат строки адреса или по иной причине).
			</td>
		</tr>
		<tr>
			<td>filter_status</td>
			<td>
				Фильтр по статусам дефектов. Может принимать значения:
				<ul>
					<li>fresh — свежий дефект, только добавлен на сайт;</li>
					<li>inprogress — в процессе, заявление в ГАИ;</li>
					<li>fixed — отремонтирован;</li>
					<li>achtung — просрочен (прошло более 37 дней с момента подачи заявления в ГАИ, никакого результата не видно);</li>
					<li>prosecutor — отправлена жалоба в прокуратуру на бездействие органов ГАИ;</li>
					<li>gibddre — получен ответ из ГАИ, но дефект не отремонтирован.</li>
				</ul>
				Если передать несуществующий статус, то дефекты выбраны не будут.<br/>
				Соответствует имени поля <code>STATE</code>.
			</td>
		</tr>
		<tr>
			<td>filter_type</td>
			<td>
				Фильтр по типу дефектов. Спектр типов дефектов довольно обширен, часть типов не используется на сайте, хотя предусмотрены:
				<ul>
					<li>badroad — разбитая дорога;</li>
					<li>holeonroad — яма на дороге;</li>
					<li>hatch — люк;</li>
					<li>crossing — переезд (не используется);</li>
					<li>nomarking — отсутствие разметки (не используется);</li>
					<li>rails — рельсы;</li>
					<li>policeman — лежачий полицейский (не используется);</li>
					<li>fence — ограждение (не используется);</li>
					<li>holeinyard — яма во дворе;</li>
					<li>light — неисправный светофор (не используется);</li>
					<li>snow — снег.</li>
				</ul>
				Если передать несуществуюший тип, то дефекты выбраны не будут.<br/>
				Соответствует имени поля <code>TYPE</code>.
			</td>
		</tr>
		<tr>
			<td>limit</td>
			<td>Количество возвращаемых дефектов. Если не указано, то берётся по умолчанию, 30 штук. На всякий случай максимальный лимит ограничен 2000 дефектами, чтоб злоумышленники не принялись выбирать дефекты десятками тысяч, положив БД и забив канал.</td>
		</tr>
		<tr>
			<td>offset</td>
			<td>Если надо выбрать некоторое количество дефектов не с первого, то можно использовать <code>offset</code> — количество дефектов между первым по порядку и первым возвращённым в выборке. Если не указано, то считается равным 0.</td>
		</tr>
		<tr>
			<td>page</td>
			<td>
				Этот параметр обладает более высоким приоритетом по сравнению с limit и offset, если указать его, то limit и offset будут проигнорированы. Смысл его в том, что он переопределяет эти параметры следующим образом:<br/>
				<pre>limit = default_limit (30 дефектов),
offset = page*default_limit.</pre>
				То есть нумерация страниц начинается с ноля.
			</td>
		</tr>
		<tr>
			<td>archive</td>
			<td>Показывать ямы из архива. По умолчанию выдаются все ямы, не помещенные в архив. При включенном параметре - выдаются ямы только из архива.</td>
		</tr>
		<tr>
			<td>polygons</td>
			<td><p>Вывести ямы по определенной территории. В качестве параметра передается двумерный массив <code>polygons[i][j]</code>, где <code>i</code> № многоугольника а <code>j</code> № точки. Сами координаты точек нужно передавать тутже в <code>['lat']</code> и <code>['lng']</code>. </p>
			  <p>Например:</p>
		    <p><pre>polygons[0][0][lat]=55.70576801798&amp;polygons[0][0][lng]=37.35893083736</pre> и т.д.</p></td>
		</tr>
	</table>
<p>Формат возвращаемого в ответе <code>XML</code>.</p>
	<p>Основная информация содержится в элементе <code>&lt;defectslist&gt;</code> в теле ответа. Там перечислены элементы <code>&lt;hole&gt;</code> - дефекты, полученные в этой выборке. Формат каждого элемента <code>&lt;hole&gt;</code> описан выше. Тело ответа, помимо присутствующих всегда элементов, содержит некоторые дополнительные:</p>
	<pre>&lt;st1234reply&gt;
	...
	&lt;sort&gt; - тут описана сортировка выбоки. В каждом элементе &lt;item&gt;, которых может быть любое количество, но обычно только один, указано направление сортировки, а в свойстве code — имя поля, по которому идёт сортировка.
		&lt;item code="ID"&gt;desc&lt;/item&gt;
		...
	&lt;/sort&gt;
	&lt;filter&gt; - тут описана фильтрация. При применении фильтров (см. таблицу выше) здесь содержатся элементы &lt;item&gt;, значение которых — значение фильтра, а свойство code — имя поля, по которому производится фильтрация, которое не совпадает с названием фильтра (опять же см. таблицу выше).
		&lt;item code="ADR_CITY"&gt;Москва&lt;/item&gt;
		...
	&lt;/filter&gt;
	&lt;navigation&gt; - параметры выборки из БД, limit и offset.
		&lt;item code="limit"&gt;30&lt;/item&gt;
		&lt;item code="offset"&gt;0&lt;/item&gt;
	&lt;/navigation&gt;
	&lt;defectslist&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		&lt;hole ...&gt;...&lt;/hole&gt;
		…
	&lt;/defectslist&gt;</pre>
        </section>



        <!-- Card
        ================================================== -->
        <section id="card">
          <div class="page-header">
            <h1>Карточка дефекта</h1>
          </div>

	<p>Карточка дефекта является общедоступной информацией, для просмотра не требуется авторизация. Чтоб получить <code>XML</code> с карточкой дефекта, надо отправить запрос методом <code>GET</code> на адрес вида <code>/&lt;id дефекта&gt;</code>, например: <code>GET /123</code> — получить дефект с номером 123 (<code>GET /123/</code> - тоже, слэш на конце не влияет на номер).</p>
	<p>Если такой дефект существует, то он будет возвращён в <code>XML</code> в теле ответа в описанном выше формате. В том случае, если он существует, но не прошёл премодерацию, будет возвращена ошибка <code>NOT_FOUND</code>.</p>
        </section>


       
      <!-- Auth
      ================================================== -->
      <section id="auth">
        <div class="page-header">
          <h1>Авторизация</h1>
        </div>

	<p>Авторизация осуществляется отправкой методом <code>GET</code> полей <code>login</code> и <code>password</code> по адресу <code>/xml/authorize</code>:</p>
	<pre>POST /xml/authorize/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	password: &lt;пароль пользователя&gt;
}</pre>
	<p>В случае, если логин и/или пароль неправильные, возвращается ошибка с кодом <code>WRONG_CREDENTIALS</code>. Если авторизация прошла успешно, будет возвращён набор данных порльзователя — его ID, ФИО и, самое главное, авторизационный хэш, который привязан к пользователю и который потом надо будет передавать серверу для подтверждения авторизованности пользователя при совершении действий, эту авторизованность требующих.</p>
	<p>Пример ответа об успешной авторизации:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1308213745&lt;/requesttime&gt;
	&lt;requestmethod&gt;POST&lt;/requestmethod&gt;
	&lt;replytime&gt;1308213746&lt;/replytime&gt;
	&lt;user id="1"&gt;
		&lt;username full="1 3 2"&gt;
			&lt;name&gt;1&lt;/name&gt;
			&lt;secondname&gt;2&lt;/secondname&gt;
			&lt;lastname&gt;3&lt;/lastname&gt;
		&lt;/username&gt;
		&lt;passwordhash&gt;&6thg^dsflo8&lt;f6ewt3h4f384bdrtg5g3efev43&lt;/passwordhash&gt;
	&lt;/user&gt;
&lt;/st1234reply&gt;</pre>

	<p>Авторизация через <code>OpenID/OAuth</code> в данный момент не реализована.</p>

	<div class="alert alert-info">
            <strong>Кроме того,</strong>
            необходимо иметь в виду, что сессия ведётся средствами <code>Yii</code>, на котором работает весь сайт УкрЯма. Также, необходимо помнить о том, что символы <code>&lt;</code> и <code>&gt;</code>, которые могут попасться в хэше, заменены HTML-последовательностями <code>&amp;lt;</code> и <code>&amp;gt;</code> соответственно. Сессия хранится долго, то есть не слетает через некоторое время бездействия, однако, нельзя гарантировать то, что она будет храниться вечно. Если приложение не хранит у себя пароль пользователя, а хранит только возвращаемый при авторизации хэш, то, для заблаговременного сообщения пользователю о том, что его сессия истекла и ему необходимо ввести пароль снова, можно воспользоваться запросом <code>CheckAuth</code>. Он ничего не делает, только проверяет, может ли пользователь авторизоваться по указанному логину и хэшу пароля. Ну и продлевает сессию, наверное, тоже.
          </div>

 <hr class="bs-docs-separator">

          <h2>Запрос CheckAuth</h2>

	<p>Осуществляется отправкой запроса методом <code>GET</code> или <code>POST</code>  по адресу <code>/checkauth/</code>:</p>
	<pre>POST /xml/checkauth/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Ответ сервера стандарный, в теле ответа присутствует всего один элемент <code>&lt;checkauthresult&gt;</code>, который содержит строку либо <code>ok</code>, либо <code>fail</code>, и имеет свойство <code>result</code>, равное <code>1</code> или <code>0</code> соответственно.</p>

 <hr class="bs-docs-separator">

              <h2>Запрос exit</h2>

	<p>На всякий случай, мало ли, вдруг понадобится, сделана и возможность разлогинится. Запрос <code>exit</code> посылается методом <code>POST</code> или <code>GET</code> по адресу <code>exit</code>:</p>
	<pre>POST /xml/exit/
GET /xml/exit/</pre>
	<p>Никаких параметров более передавать не нужно. Тело ответа всегда будет сообщать об успешном завершении процедуры. Выглядит это так:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1308220587&lt;/requesttime&gt;
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt;
	&lt;replytime&gt;1308220588&lt;/replytime&gt;
	&lt;callresult result="1"&gt;ok&lt;/callresult&gt;
&lt;/st1234reply&gt;</pre>

          </section>


          <!-- Profile
          ================================================== -->
          <section id="profile">
            <div class="page-header">
              <h1>Профиль пользователя</h1>
            </div>

	<p>Подробную информацию о пользователе можно получить запросом <code>POST</code> по адресу: <code>/xml/profile/&lt;ID пользователя&gt;/</code>.</p>

	<p>В случае, если логин и/или пароль неправильные, возвращается ошибка с кодом <code>WRONG_CREDENTIALS</code>. Если авторизация прошла успешно, будет возвращён набор данных порльзователя — его ID, ФИО и, если пользователь разрешил публикацию своей зоны наблюдения, координаты точек многоугольников пользовательской зоны.</p>
	<p>Пример ответа:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;st1234reply&gt;
	&lt;requesttime&gt;1308213745&lt;/requesttime&gt;
	&lt;requestmethod&gt;POST&lt;/requestmethod&gt;
	&lt;replytime&gt;1308213746&lt;/replytime&gt;
	&lt;user id="1"&gt;
		&lt;username full="1 3 2"&gt;
			&lt;name&gt;1&lt;/name&gt;
			&lt;secondname&gt;2&lt;/secondname&gt;
			&lt;lastname&gt;3&lt;/lastname&gt;
		&lt;/username&gt;
		&lt;passwordhash&gt;&6thg^dsflo8&lt;f6ewt3h4f384bdrtg5g3efev43&lt;/passwordhash&gt;
	&lt;area&gt;<br>		&lt;polygon&gt;<br>			&lt;point&gt;<br>				&lt;lat&gt;<br>					55.70576801798<br>				&lt;/lat&gt;<br>				&lt;lng&gt;<br>					37.35893083736<br>				&lt;/lng&gt;<br>			&lt;/point&gt;<br>			&lt;point&gt;<br>				&lt;lat&gt;<br>					55.86373205569<br>				&lt;/lat&gt;<br>				&lt;lng&gt;<br>					37.35893083736<br>				&lt;/lng&gt;<br>			&lt;/point&gt;<br>			&lt;point&gt;<br>				&lt;lat&gt;<br>					55.86373205569<br>				&lt;/lat&gt;<br>				&lt;lng&gt;<br>					37.66767103225<br>				&lt;/lng&gt;<br>			&lt;/point&gt;<br>			....<br>		&lt;/polygon&gt;
		....<br>	&lt;/area&gt;
	&lt;/user&gt;
&lt;/st1234reply&gt;</pre>	

          </section>



           <!-- User holes
          ================================================== -->
          <section id="userholes">
            <div class="page-header">
              <h1>Список дефектов, выложенных на сайт пользователем</h1>
            </div>

	<p>Список дефектов, которые выложил на сайт определённый пользователь получается запросом методом <code>POST</code> по адресу <code>/xml/my/</code>:</p>
	<pre>POST /xml/my/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля, полученный при авторизации&gt;
}</pre>
	<p>Вместо поля passwordhash может быть передан собственно пароль в поле password (тогда поле <code>passwordhash</code> должно отсутствовать вообще, а не быть нулевой длины). В том случае, если логин и хэш пароля (пароль) принадлежат одному пользователю, то в ответе содержится список дефектов, выложенных на сайт этим пользователем, в том числе и те, которые ещё не прошли премодерацию. В противном случае ответ будет содержать ошибку <code>AUTHORIZATION_REQUIRED</code>.</p>
	<p>К списку собственных дефектов может быть применён фильтр, аналогичный фильтру обычного списка дефектов, и выглядит он точно так же.</p>


          </section>


          <!-- User view
          ================================================== -->
          <section id="userview">
            <div class="page-header">
              <h1>Просмотр карточки дефекта с правами пользователя</h1>
            </div>

	<p>Авторизованный пользователь может смотреть информацию по каждому из загруженных им дефектов, даже по тем, которые ещё не прошли премодерацию. Для этого надо отправить запрос методом <code>POST</code> по адресу <code>/xml/my/xxx/</code>, где <code>xxx</code> — номер дефекта, который пользователь хочет посмотреть. Например:</p>
	<pre>POST /xml/my/154/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля, полученный при авторизации&gt;
}</pre>
	<p>Вместо поля <code>passwordhash</code> может быть передан собственно пароль в поле <code>password</code> (тогда поле <code>passwordhash</code> должно отсутствовать вообще, а не быть нулевой длины). В том случае, если логин и хэш пароля (пароль) принадлежат пользователю, загрузившему на сайт указанный дефект (в примере — дефект №154), то будет возвращено описание запрошенного дефекта. Если логин и хэш пароля (пароль) не принадлежат одному пользователю, будет возвращена ошибка <code>AUTHORIZATION_REQUIRED</code>, а если дефект принадлежит другому пользователю, то будет возвращена ошибка <code>NOT_FOUND</code>.</p>
          </section>

          <!-- Работа с дефектами
          ================================================== -->
          <section id="defects">
            <div class="page-header">
              <h1>Работа с дефектами</h1>
            </div>

	<h3>Добавление дефекта</h3>
	<p>Добавление дефекта осуществляется отправкой необходимых данных методом <code>POST</code> по адресу <code>/add/</code>.</p>
	<pre>POST /xml/add/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	address: &lt;адрес ямы, желательно в формате xAL&gt;
	latitude: &lt;широта дефекта&gt;
	longitude: &lt;долгота дефекта&gt;
	comment: &lt;комментарий пользователя к дефекту&gt;
	type: &lt;тип дефекта&gt;
}</pre>
	<p>Кроме того, должен быть передан хотя бы один графический файл с фотографией ямы.</p>
	<p>Комментарии к передаваемым полям <code>POST</code>:</p>
	<table class="table table-bordered table-striped">
		<tr>
			<td>passwordhash</td>
			<td>Содержит хэш пароля. Вместо этого поля можно передать пароль в поле <code>password</code>, но тогда поле <code>passwordhash</code> должно отсутствовать (а не быть равным пустой строке).</td>
		</tr>
		<tr>
			<td>login</td>
			<td>Логин пользователя. В том случае, если логин и пароль (хэш пароля) не соответствуют одному пользователю, будет возвращена ошибка <code>AUTHORIZATION_REQUIRED</code>.</td>
		</tr>
		<tr>
			<td>address</td>
			<td>
				Адрес должен быть в формате <code>xAL</code>, или, по крайней мере, начинаться как адрес в этом формате. Определение текстового поля «название города» происходит именно на основании данных адреса. Поэтому хорошей практикой может считаться определение адреса по координатам с помощью обратного геокодирования, и позволение пользователю дописать что-то в конец адреса, или слегка отредактировать первую часть адреса, но тогда не исключена такая ситуация, что дефект, территориально расположенный в городе N, будет не находиться в этом городе при поиске по названию города N. Адрес является обязательным параметром, при его отсутствии будет возвращена ошибка <code>NO_ADDRESS</code>.<br/>
				А если не удалось опередить город, то генеририуется предупреждение <code>CANNOT_REALISE_CITY</code>.
			</td>
		</tr>
		<tr>
			<td>latitude, longitude</td>
			<td>Широта и долгота месторасположения дефекта. Их можно не передавать по отдельности, а передать сразу в поле <code>coordinates</code> перечисленными через запятую, сначала широта, потом долгота. Либо передать их в поле <code>coordinatesr</code> через запятую, но сначала долгота, а потом широта. Координаты должны быть переданы, это обязательные параметры. В том случае, если они не будут переданы, будут возвращены ошибки <code>LATITUDE_NOT_SET</code> или <code>LONGITUDE_NOT_SET</code>.</td>
		</tr>
		<tr>
			<td>comment</td>
			<td>Текстовый комментарий к дефекту, может быть пустым.</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Тип дефекта, один из возможных. При указании несуществующего типа будет возвращена ошибка <code>INCORRECT_TYPE</code>, при указании существующего, но неиспользуемого типа дефектов будет возвращена ошибка <code>DEPRECATED_TYPE</code>.</td>
		</tr>
	</table>

	 <hr class="bs-docs-separator">

	<h3>Комментарии к файлам</h3>
	<p>Файлы должны быть переданы именно как файлы (<code>encryption type</code> должно быть <code>multipart/form-data</code>). Имена, под которыми файлы передаются на сервер, не имеют значения, но их должно быть не больше десяти. Обрабатываться они будут в том порядке, в котором будут переданы на сервер. В том случае, если файлов будет больше, чем десять, те файлы, которые были переданы после десятого, не будут обработаны, и будет выдано предупреждение <code>FILES_DROPPED</code>.</p>
	<p>В том случае, если суммарный размер файлов превышает допустимые ограничения, никакой специфической ошибки не возвращается, так как веб-сервер обычно обрабатывает эту ситуацию самостоятельно. Вероятнее всего в этом случае можно получить ошибку <code>AUTHORIZATION_REQUIRED</code>. Узнать максимальный размер одного файла и максимальный суммарный размер файлов можно с помощью запроса <code>GetFileUploadLimits</code>.</p>
	<p>В случае, если при загрузке файлов произошли какие-то другие ошибки, то они будут выведены в <code>XML</code>.</p>
	<p>Ошибки, которые могут возникнуть при загрузке файлов:</p>
	<table class="table table-bordered table-striped">
		<tr>
			<td>NO_FILES</td>
			<td>Ни одного файла не загружено</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Слишком большой файл</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Слишком много файлов (количество превышает директиву <code>max_file_uploads</code> в <code>php.ini</code>) — но эту ошибку вряд ли можно наблюдать, если честно</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>Файл загружен только частично</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Невозможно загрузить файл.<br/>
				Это сообщение выдаётся в случае, если загрузить файлы не удалось по какой-то внутренней причине, о которой пользователю знать не обязательно — проблемы с записью на диск, с правами доступа и так далее.</td>
			</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Неподдерживаемый формат файла.<br/>
				В качестве изображений принимаются картинки форматов <code>JPEG</code>, <code>PNG</code> и <code>GIF</code>, попытка загрузить файл любого другого формата вызовет эту ошибку.</td>
			</td>
		</tr>
		<tr>
			<td>UPLOAD_ERROR</td>
			<td>
				Неизвестный формат изображения.<br/>
				Если <code>mime-type</code> и содержимое картинки не совпадают или что-то случилось на сервере, что не позволяет открыть этот файл для пережатия в меньший размер, то будет показана эта ошибка.
			</td>
		</tr>
	</table>
	<p>В том случае, если по какой-то причине не удалось добавить дефект, то будет возвращена ошибка <code>CANNOT_ADD_DEFECT</code>, в которой будет описание, почему, собственно, не удалось добавить дефект, и элемент <code>callresult</code> с результатом <code>0</code> (<code>fail</code>). В том случае, если дефект добавить удалось, будет возвращён его идентификатор в элементе <code>XML</code>-репорте об успешном завершении операции:</p>
	<pre>&lt;callresult result="1" inserteddefectid="32"&gt;ok&lt;/callresult&gt;</pre>
	<p>В свойстве <code>inserteddefectid</code> элемента <code>callresult</code> находится идентификатор добавленного дефекта.</p>

 <hr class="bs-docs-separator">

        <h2>Запрос GetFileUploadLimits</h2>

	<p>Запрос позволяет выяснить настройки <code>PHP</code> на сервере и прочие ограничения, присутствующие при загрузке фалов на сервер. Отправляется методом <code>GET</code> по адресу <code>/getfileuploadlimits</code>:</p>
	<pre>GET /getfileuploadlimits</pre>
	<p>Запрос авторизации не требует и возвращает вот такой <code>XML</code>:</p>
	<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;st1234reply&gt; 
	&lt;requesttime&gt;1308920653&lt;/requesttime&gt; 
	&lt;requestmethod&gt;GET&lt;/requestmethod&gt; 
	&lt;replytime&gt;1308920653&lt;/replytime&gt; 
	&lt;maxpostsize&gt;1M&lt;/maxpostsize&gt; 
	&lt;maxfilesize&gt;3M&lt;/maxfilesize&gt; 
	&lt;maxfilescount&gt;10&lt;/maxfilescount&gt; 
&lt;/st1234reply&gt;</pre>
	<p>Элементы <code>&lt;maxpostsize&gt;</code> и <code>&lt;maxfilesize&gt;</code> содержат значения значений <code>post_max_size</code> и <code>upload_max_filesize</code> из <code>php.ini</code> в том виде, в каком они содержатся там; как видно в примере — даже без проверок на адекватность. Элемент <code>maxfilescount</code> содержит максимальное число файлов, которое можно загрузить за один раз.</p>

 <hr class="bs-docs-separator">

              <h2>Изменение дефекта</h2>

	<p>Существует несколько запросов, позволяющих изменить дефект. Эти запросы различны по тем данным, которые могут быть изменены, и по тому, когда они могут быть вызваны, это зависит от статуса дефекта. По своей сути эти запросы сводятся к одному универсальному, но снаружи этого не видно.</p>
	<p>Список запросов, которыми можно изменять дефект.</p>
	<table class="table table-bordered table-striped">
		<tr>
			<th>Запрос</th>
			<th>Статус дефекта, когда может быть вызван запрос</th>
			<th>Поля, которые можно изменять, и прочие допустимые изменения</th>
		</tr>
		<tr>
			<td>update</td>
			<td>новый</td>
			<td>координаты, тип, строка адреса, комментарий, можно загружать ещё файлы и удалять имеющиеся</td>
		</tr>
		<tr>
			<td>set_inprogress</td>
			<td>новый, исправлено</td>
			<td>меняется статус на «в процессе». Для дефекта в статусе «исправлено» этот запрос доступен только в том случае, если не была загружена фотография исправленного дефекта, и статус может измениться на «просрочен» или «получен ответ из гибдд», в зависимости от того, какой был статус до статуса «исправлен»</td>
		</tr>
		<tr>
			<td>revoke</td>
			<td>в процессе</td>
			<td>меняется статус обратно на «новый»</td>
		</tr>
		<tr>
			<td>set_replied</td>
			<td>в процессе, получен ответ, просрочен</td>
			<td>меняется статус на «получен ответ из ГАИ», необходимо добавить одно или несколько изображений (обычно скан ответа из ГАИ) и, по желанию, комментарий. Можно удалить ранее загруженный ответ из ГАИ</td>
		</tr>
		<tr>
			<td>set_fixed</td>
			<td>все, кроме «исправлено»</td>
			<td>меняется статус на «исправлено», можно добавить одно или несколько изображений и комментарий</td>
		</tr>
		<tr>
			<td>to_prosecutor</td>
			<td>просрочен</td>
			<td>статус меняется на «жалоба в прокуратуру подана»</td>
		</tr>
		<tr>
			<td>revoke_p</td>
			<td>жалоба в прокуратуру подана</td>
			<td>статус меняется обратно на «просрочен»</td>
		</tr>
	</table>
	<p>Дефект переходит из статуса «в процессе» в статус «просрочен» самостоятельно с течением времени.</p>
	<p>Для удобства пользования существует служебный запрос <code>GetUpdateMethods</code>, который сообщает список возможных способов изменить дефект, а также — какие поля принимаются при каждом запросе.</p>

 <hr class="bs-docs-separator">

              <h2>Вызов GetUpdateMethods</h2>

	<p>Вызов существует в двух вариантах — в общем случае и применительно к дефекту. В общем случае вызывается методом <code>GET</code> адрес <code>/getupdatemethods</code>:</p>
	<pre>GET /getupdatemethods</pre>
	<p>Применительно к одному дефекту он вызывается методом <code>POST</code> по адресу <code>/xml/my/&lt;defect_id&gt;/getupdatemethods</code>:</p>
	<pre>POST /xml/my/&lt;defect_id&gt;/getupdatemethods
Поля POST
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Как и в других случах, тут вместо хэша пароля можно передать собственно пароль в поле <code>password</code>, а поле <code>passwordhash</code> в таком случае должно отсутствовать. В том случае, если логин и пароль не подходят, будет выдана ошибка <code>AUTHORIZATION_REQUIRED</code>. В том случае, если дефект с номером <code>&lt;defect_id&gt;</code> отсутствует или загружен другим пользователем, будет выдана ошибка <code>NOT_FOUND</code>.</p>
	<p>В общем случае тело ответа сервера выглядит следующим образом:</p>
	<pre>&lt;state id="state-id"&gt;
	&lt;method name="method-name"&gt; 
		&lt;field&gt;field_name&lt;/field&gt;
		...
	&lt;/method&gt;
	... 
&lt;/state&gt;
…</pre>
	<p>В теле ответа перечислены элементы <code>state</code> (теоретически, их может и не быть), каждый из которых соответствует статусу дефекта. В случае, если вы запрашиваете этот метод для одного дефекта, то элемент <code>state</code> будет максимум один — соответствующий статусу выбранного дефекта. У элемента <code>state</code> есть свойство <code>id</code> — это код статуса дефекта.</p>
	<p>Внутри элемента <code>state</code> расположены элементы <code>method</code>, каждый из которых соответствует методу обновления дефекта, который может быть вызван для дефекта в текущем статусе. Соответственно, этих элементов тоже может не быть. У элемента <code>method</code> есть свойство <code>name</code>, которое является именем этого метода.</p>
	<p>Внутри элемента <code>method</code> расположены элементы <code>field</code> (их тоже может не быть), каждый из которых соответствует свойству дефекта, который может быть изменён данным методом. И является ключом массива с данными, который передаётся методом <code>POST</code> при обновлении дефекта. Более подробно о кодах <code>field</code> см. в описании метода обновления <code>update</code>.</p>

 <hr class="bs-docs-separator">

              <h2>Метод обновления дефекта update</h2>

	<p>Это наиболее полный метод обновления дефекта, с помощью которого данные дефекта можно обновить полностью (за исключением авторства и даты создания, разумеется). Поэтому данный метод применим только к дефектам в статусе «новый».</p>
	<p>Вызывается данный метод отправкой данных методом <code>POST</code> на адрес <code>/xml/my/&lt;defect-id&gt;/update</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/update
Поля POST (практически идентичны с методом добавления дефекта):
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	address: &lt;адрес ямы, желательно в формате xAL&gt;
	latitude: &lt;широта дефекта&gt;
	longitude: &lt;долгота дефекта&gt;
	comment: &lt;комментарий пользователя к дефекту&gt;
	type: &lt;тип дефекта&gt;
	deletefiles: &lt;удаляемые файлы&gt;
}</pre>
	<p>Кроме того, могут быть переданы графические файлы, который добавятся к дефекту.</p>
	<p>Комментарии к передаваемым полям <code>POST</code>:</p>
	<table class="table table-bordered table-striped">
		<tr>
			<td>passwordhash</td>
			<td>Содержит хэш пароля. Вместо этого поля можно передать пароль в поле <code>password</code>, но тогда поле passwordhash должно отсутствовать (а не быть равным пустой строке).</td>
		</tr>
		<tr>
			<td>login</td>
			<td>Логин пользователя. В том случае, если логин и пароль (хэш пароля) не соответствуют одному пользователю, будет возвращена ошибка <code>AUTHORIZATION_REQUIRED</code>.</td>
		</tr>
		<tr>
			<td>address</td>
			<td>
				Адрес должен быть в формате <code>xAL</code>, или, по крайней мере, начинаться как адрес в этом формате. Если адрес не передан, то адрес дефекта не изменится. 
				А если не удалось опередить город, то генерируется предупреждение <code>CANNOT_REALISE_CITY</code>. Желательно передавать адрес полный, полученный с помощью геокодера. Допускатся передавать адрес частичный, совпадающий с полем <code>address</code> дефекта, но в том случае, если он будет изменён, невозможно гарантировать то, что будет сохранён город и регион дефекта.
			</td>
		</tr>
		<tr>
			<td>latitude, longitude</td>
			<td>
				Широта и долгота месторасположения дефекта. Их можно не передавать по отдельности, а передать сразу в поле <code>coordinates</code> перечисленными через запятую, сначала широта, потом долгота. Либо передать их в поле <code>coordinatesr</code> через запятую, но сначала долгота, а потом широта.<br/>
				Если координаты не переданы, то координаты дефекта не изменятся.
			</td>
		</tr>
		<tr>
			<td>comment</td>
			<td>Текстовый комментарий к дефекту, может быть пустым. Если не передан, то не комментарий к дефекту не изменится.</td>
		</tr>
		<tr>
			<td>type</td>
			<td>Тип дефекта, один из возможных. При указании несуществующего типа будет возвращена ошибка <code>INCORRECT_TYPE</code>, при указании существующего, но неиспользуемого типа дефектов будет возвращена ошибка <code>DEPRECATED_TYPE</code>. Если тип не передан, то тип дефекта не изменится.</td>
		</tr>
		<tr>
			<td>deletefiles</td>
			<td>Массив <code>ID</code> изображений.</td>
		</tr>
	</table>
	<p>Комментарии к загружаемым файлам аналогичны случаю создания дефекта. С помощью многократного редактирования дефекта можно загрузить достаточно большое количество файлов, но их суммарное количество не должно превышать 100, в противном случае будут выведены предупреждения <code>FILES_DROPPED</code> и <code>FILES_LIMIT_REACHED</code> (достигнуто максимальное количество файлов для дефекта).</p></p>
	<p>В том случае, если данный метод неприменим для дефекта из-за того, что последний не в статусе «новый», будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code> (неподходящий метод).
	<p>Если обновление дефекта прошло успешно, то будет выведен элемент <code>&lt;callresult result="1"&gt;ok&lt;/callresult&gt;</code>, в противном случае будет выведен элемент <code>&lt;callresult result="0"&gt;fail&lt;/callresult&gt;</code> и ошибка <code>CANNOT_UPDATE_DEFECT</code> (не удалось обновить дефект) в том случае, если произошёл какой-то сбой иного рода, элемент <code>error</code> будет содержать текст ошибки, например:</p>
	<pre>&lt;error code="CANNOT_UPDATE_DEFECT"&gt;Неподдерживаемый формат изображения&lt;/error&gt;</pre>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта set_inprogress</h2>
	<p>Метод предназначен, в основном, для перевода дефекта из статуса «новый» в статус «в процессе», однако, может применяться и для отмены статуса «исправлен» в том случае, если ещё не была загружена фотография исправленного дефекта. Вызывается отправкой запроса методом <code>POST</code> на адрес <code>/xml/my/&lt;defect-id&gt;/setinprogress</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/setinpgogress
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки.</p>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта revoke</h2>
	<p>Метод служит для возвращения дефекту, который в статусе «в процессе», статуса «новый». Соответственно, применим только для дефектов в статусе «в процессе». Вызывается отправкой запроса методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/revoke</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/revoke
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо passwordhash может быть передан password.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки.</p>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта set_replied</h2>
	<p>Данный метод предназначен для перевода дефекта из статуса «в процессе» в статус «получен ответ из ГАИ» или для добавления ещё сканов ответа из ГАИ. Применим только к дефектам в статусе «в процессе». Вызывается отправкой запроса методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/setreplied</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/setreplied
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	comment: &lt;комментарий&gt;
	deletefiles: &lt;список удаляемых файлов ответов ГАИ через запятую&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>Должен быть передан как минимум один графический файл, являющийся, по замыслу, сканом ответа из ГАИ. Максимальное число файлов всё так же 10. Комментарий не обязателен.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки. Если не загружено ни одного файла, будет выдана ошибка <code>NO_FILES</code>. Также могут быть выданы ошибки, связанные с загрузкой файлов, аналогичные описанным в разделе о методе обновления <code>update</code>.</p>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта set_fixed</h2>
	<p>Данный метод предназначен для перевода дефекта в статус «исправлено». Применим к дефекту в любом статусе, кроме «новый» и «исправлено». Вызывается отправкой запроса методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/setfixed</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/setfixed
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	comment: &lt;комментарий&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>Комментарий не обязателен. Также могут быть переданы графические файлы, но они тоже не обязательны, и к ним относятся все замечания, касающиеся загрузки файлов, для вышеописанных методов.</p>
	<p>Следует отметить отдельно, что в том случае, если файл не был загружен, то дефект можно вернуть в статус «в процессе» (или «просрочен»), а если был загружен файл, то нельзя.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки. Если не загружено ни одного файла, будет выдана ошибка <code>NO_FILES</code>. Также могут быть выданы ошибки, связанные с загрузкой файлов, аналогичные описанным в разделе о методе обновления <code>update</code>.</p>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта to_prosecutor</h2>
	<p>Метод служит для простановки дефекту статуса «заявление отправлено в прокуратуру». Метод применим только для просроченных дефектов (находящихся в статусе «просрочен»). Вызывается отправкой запроса методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/toprosecutor</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/toprosecutor
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки.</p>

 <hr class="bs-docs-separator">

	<h2>Метод обновления дефекта revoke_p</h2>
	<p>Метод служит для простановки дефекту в статуске «заявление в прокуратуре» статуса «просрочен». Вызывается отправкой запроса методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/revokep</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/revokep
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_UPDATE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки.</p>

 <hr class="bs-docs-separator">

	<h2>Удаление дефекта</h2>
	<p>Удалить можно только дефект в статусе «новый». Для этого надо отправить запрос методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/delete</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/delete
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В том случае, если метод неприменим, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Результат выполнения выводится в элементе <code>&lt;callresult&gt;</code>. Если произошла какая-то иная ошибка, то будет выведена ошибка <code>CANNOT_DELETE_DEFECT</code>, элемент <code>error</code> будет содержать текст ошибки.</p>

          </section>


        <!-- Геокодирование
        ================================================== -->
        <section id="geocode">
          <div class="page-header">
            <h1>Геокодирование</h1>
          </div>

	<div class="alert alert-info">
            <strong>Прямое геокодирование</strong>
             — определение координат по топониму. Обратное — наоборот. Для уменьшения злоупотребления геокодированием авторизация пользователя является обязательной. Фактически, геокодер УкрЯмы является прокси-сервером для геокодера Google Map, так что можно обращаться напрямую в Google Map, и ответ сервера практически совпадает с ответом Google Map.
          </div>

	<p>Геокодирование получается обращением методом <code>POST</code> по адресу <code>/geocode/</code>:</p>
	<pre>POST /xml/geocode/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	geocode: &lt;любая строка или координаты через запятую&gt;
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<div class="alert alert-info">
            <strong>Обратите внимание,</strong>
             что в поле <code>geocode</code> передаётся сначала долгота, потом широта.
          </div>

	<p>Ответ сервера содержит в себе элемент <code>&lt;geocode&gt;</code>, в котором целиком содержится (за исключением тэга <code>&lt;?xml&gt;</code>) ответ Яндекса в формате <code>XML</code> (пробелы, которыми сделан отступ строк слева, заменены на символы табуляции). В случае ошибки элемент <code>&lt;geocode&gt;</code> отсутствует, а вместо него выводится ошибка. Если не указан адрес или координаты, то выводится ошибка <code>GEOCODE_EMPTY_REQUEST</code> (пустой запрос к геокодеру), в случае каких-либо иных ошибок выводится <code>GEOCODE_ERROR</code>.</p>

        </section>


      

        <!-- Получение с сервера PDF
        ================================================== -->
        <section id="pdf">
          <div class="page-header">
            <h1>Получение с сервера PDF</h1>
          </div>

	<p>В некоторых ситуациях вместо ответа в формате <code>XML</code> сервер может предложить для скачивания <code>PDF</code>-файл со сформированным заявлением в прокуратуру или жалобой в ГАИ. Для получения с сервера <code>PDF</code> необходимо отправить запрос методом <code>POST</code> по определённому адресу и передать заполненные поля, которые подставятся в текст.</p>

	<h2>Формирование и получение с сервера жалобы в ГАИ</h2>
	<p>Для получения с сервера жалобы в ГАИ в формате PDF или текста необходимо отправить на сервер запрос методом <code>POST</code> по адресу <code>/xml/my/&lt;defect-id&gt;/pdf_gibdd/</code>:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/pdf_gibdd/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	to: &lt;кому&gt;
	from: &lt;от кого&gt;
	postaddress: &lt;почтовый адрес отправителя&gt;
	holeaddress: &lt;адрес дефекта&gt;
	signature: &lt;подпись (фамилия и инициалы отправителя)&gt;
	html: [Не обязательный boolean параметр. Если true ответ будет выдан ввиде строки размеченой html]
	textonly: [Не обязательный boolean параметр. Если true ответ будет выдан ввиде текстовой строки]
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В поле <code>from</code> должно быть указано полное имя отправителя. </p>
	<p>Данный запрос применим только к дефектам, находящимся в статусах «новый» и «в процессе». В случае, если дефект находится не в этих статусах, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Скрипты на сайте не проверяют валидность вводимых данных. Сгенерированный текст заявления не хранится на сервере.</p>

 <hr class="bs-docs-separator">

	<h2>Формирование и получение с сервера заявления в прокуратуру</h2>
	<p>Для получения с сервера жалобы в ГАИ в формате PDF или текста необходимо отправить на сервер запрос методом POST по адресу /xml/my/&lt;defect-id&gt;/pdf_prosecutor/:</p>
	<pre>POST /xml/my/&lt;defect-id&gt;/pdf_prosecutor/
Поля POST:
{
	login: &lt;логин пользователя&gt;
	passwordhash: &lt;хэш пароля&gt;
	from: &lt;от кого&gt;
	postaddress: &lt;почтовый адрес отправителя&gt;
	holeaddress: &lt;адрес дефекта&gt;
	signature: &lt;подпись (фамилия и инициалы отправителя)&gt;
	gibdd: &lt;название отделения ГАИ&gt;
	gibddre: &lt;ответ ГАИ&gt;
	html: [Не обязательный boolean параметр. Если true ответ будет выдан ввиде строки размеченой html]
	textonly: [Не обязательный boolean параметр. Если true ответ будет выдан ввиде текстовой строки]
}</pre>
	<p>Вместо <code>passwordhash</code> может быть передан <code>password</code>.</p>
	<p>В поле <code>from</code> должно быть указано полное имя отправителя. Так как на сайте в профиле может быть не указано полное правильное имя пользователя, имеется возможность указать его отдельно. В поле <code>postaddress</code> необходимо указать свой полный почтовый адрес. На сайте не хранятся почтовые адреса пользователей. Адрес дефекта нужно указать чётко, чтоб было понятно в прокуратуре. Поле <code>gibdd</code> должно содержать название отделения ГАИ, куда было направлено заявление. Для его получения можно воспользоваться запросом <code>getgibddhead</code>. Поле gibddre должно содержать содержательную часть ответа из ГАИ и используется только в том случае, если этот ответ получен. Отправить заявление в прокуратуру можно, когда дефект находится в двух статусах: «просрочен» и «получен ответ из ГАИ», в обоих случаях текст заявление будет разный, в первом случае — жалоба на бездействие ГАИ, во втором — заявление о нарушении закнодательства о содержании и ремонте дорог и безопасности дорожного движения. В том случае, если дефект находится в другом статусе, будет выведена ошибка <code>UNAPPROPRIATE_METHOD</code>. Скрипты на сайте не проверяют валидность вводимых данных. Сгенерированный текст заявления не хранится на сервере.</p>

        </section>

      </div>
    </div>

  </div>





